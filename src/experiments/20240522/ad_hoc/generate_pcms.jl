# This file is auto-generated from generate_pcms.jmd.
# Do not edit this file manually.

module PCMsGenerator

using Distributions
using IntervalArithmetic
using IntervalArithmetic.Symbols

include("../../../utils/ahp/crisp_pcm/v1/crisp_pcm.jl")
using .CrispPCM

include("../../../utils/ahp/interval_pcm/v1/interval_pcm.jl")
using .IntervalPCM

const databasePath = "../experiment_202405.sqlite"

const S = 9

function generateCrispPCM(
    n::Int
)::Matrix{Float64}
    A = Matrix(undef, n, n)

    for i in 1:n
        for j in i:n
            if i == j
                A[i, j] = 1.0
                continue
            end

            aᵢⱼ = exp(rand(Uniform(log(1/S), log(S))))
            A[i, j] = aᵢⱼ
            A[j, i] = 1 / aᵢⱼ
        end
    end

    return A
end

function generateConsistentCrispPCM(
    n::Int;
    max_iter::Int = 10000
)::Matrix{Float64}
    for _ in 1:max_iter
        A = generateCrispPCM(n)
        if !isCrispPCM(A) continue end
        if CR(A) ≥ 0.1 continue end
        return A
    end

    error("Failed to generate a consistent crisp PCM after $max_iter iterations")
end

function generateIntervalPCM(
    A::Matrix{T}
)::Matrix{Interval{T}} where {T <: Real}
    if !isCrispPCM(A)
        error("The input matrix is not a crisp PCM")
    end

    n = size(A, 1)
    B = Matrix{Interval{T}}(undef, n, n)
    for i in 1:n
        for j in i:n
            if i == j
                B[i, j] = 1..1
                continue
            end

            aᵢⱼ = A[i, j]
            rᵢⱼᴸ = rand(Uniform(1e-8, log(7)/2))
            rᵢⱼᵁ = rand(Uniform(1e-8, log(7)/2))
            bᵢⱼᴸ = aᵢⱼ * exp(-rᵢⱼᴸ)
            bᵢⱼᵁ = aᵢⱼ * exp(rᵢⱼᵁ)
            B[i, j] = bᵢⱼᴸ..bᵢⱼᵁ
            B[j, i] = (1 / bᵢⱼᵁ)..(1 / bᵢⱼᴸ)
        end
    end

    if !isIntervalPCM(B)
        error("Failed to generate an interval PCM")
    end

    return B
end

function discritize(a::T)::T where {T <: Real}
    sorted_scale = sort(vcat(1 ./ (S:-1:2), [1], 2:S))
    boundaries = [sqrt(sorted_scale[i] * sorted_scale[i+1]) for i in 1:length(sorted_scale)-1]

    for i in eachindex(boundaries)
        if a ≤ boundaries[i]
            return sorted_scale[i]
        end
    end

    return last(sorted_scale)
end

function discritize(
    A::Matrix{Interval{T}}
)::Matrix{Interval{T}} where {T <: Real}
    if !isIntervalPCM(A)
        error("The input matrix is not an interval PCM")
    end

    n = size(A, 1)
    B = Matrix{Interval{T}}(undef, n, n)

    for i = 1:n, j = i:n
        if i == j
            B[i, j] = 1..1
            continue
        end

        aᵢⱼ = A[i, j]
        aᵢⱼᴸ = discritize(inf(aᵢⱼ))
        aᵢⱼᵁ = discritize(sup(aᵢⱼ))
        B[i, j] = aᵢⱼᴸ..aᵢⱼᵁ
        B[j, i] = (1 / aᵢⱼᵁ)..(1 / aᵢⱼᴸ)
    end

    return B
end

"""
    generateIntervalPCMSet(; n, sample_size, M, callback)

Generate experiment cases of interval PCMs.

`callback(interval_pcm_set::Vector{Vector{Matrix{Interval{Float64}}}}, i::Int)`
"""
function generateIntervalPCMSet(;
    n::Int,
    sample_size::Int,
    M::Int,
    callback::Function
)
    Threads.@threads for i in 1:sample_size
        try
            crisp_pcm = generateConsistentCrispPCM(n)
            interval_pcm_samples = [generateIntervalPCM(crisp_pcm) for _ in 1:M]
            callback(interval_pcm_samples, i)
        catch e
            println("Error occurred in $i-th iteration: ", e)
        end
    end
end

export generateIntervalPCMSet

end
