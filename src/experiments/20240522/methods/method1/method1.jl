# This file is auto-generated from method1.jmd.
# Do not edit this file manually.

module Method1

using IntervalArithmetic
using IntervalArithmetic.Symbols
using HiGHS
using JuMP

include("../../../../utils/ahp/nearly_equal/v1/nearly_equal.jl")
using .NearlyEqual

include("../../../../utils/ahp/interval_pcm/v1/interval_pcm.jl")
using .IntervalPCM

include("../../../../utils/ahp/twofold_interval/v1/twofold_interval.jl")
using .TwofoldIntervalArithmetic

include("../../../../utils/ahp/twofold_interval_pcm/v1/twofold_interval_pcm.jl")
using .TwofoldIntervalPCM

function combineIntervalPCMs(
    A‚ÇÅ::Matrix{Interval{T}},
    A‚ÇÇ::Matrix{Interval{T}}
)::Matrix{TwofoldInterval{T}} where {T <: Real}
    if !isIntervalPCM(A‚ÇÅ) || !isIntervalPCM(A‚ÇÇ)
        throw(ArgumentError("A‚ÇÅ and A‚ÇÇ must be Interval PCMs."))
    end
    if size(A‚ÇÅ) != size(A‚ÇÇ)
        throw(ArgumentError("A‚ÇÅ and A‚ÇÇ must have the same size."))
    end

    n = size(A‚ÇÅ, 1)

    ùíú = Matrix{TwofoldInterval{T}}(undef, n, n)

    for i = 1:n
        for j = i:n
            if i == j
                ùíú[i,j] = (1.0..1.0, 1.0..1.0)
                continue
            end

            A‚ÇÅ·µ¢‚±º = A‚ÇÅ[i, j]; A‚ÇÇ·µ¢‚±º = A‚ÇÇ[i, j]
            a‚ÇÅ·µ¢‚±º·¥∏ = inf(A‚ÇÅ·µ¢‚±º); a‚ÇÅ·µ¢‚±º·µÅ = sup(A‚ÇÅ·µ¢‚±º)
            a‚ÇÇ·µ¢‚±º·¥∏ = inf(A‚ÇÇ·µ¢‚±º); a‚ÇÇ·µ¢‚±º·µÅ = sup(A‚ÇÇ·µ¢‚±º)

            Œ±·µ¢‚±º·¥∏‚Å∫ = min(a‚ÇÅ·µ¢‚±º·¥∏, a‚ÇÇ·µ¢‚±º·¥∏)
            Œ±·µ¢‚±º·¥∏‚Åª = max(a‚ÇÅ·µ¢‚±º·¥∏, a‚ÇÇ·µ¢‚±º·¥∏)
            Œ±·µ¢‚±º·µÅ‚Åª = min(a‚ÇÅ·µ¢‚±º·µÅ, a‚ÇÇ·µ¢‚±º·µÅ)
            Œ±·µ¢‚±º·µÅ‚Å∫ = max(a‚ÇÅ·µ¢‚±º·µÅ, a‚ÇÇ·µ¢‚±º·µÅ)

            ùíú[i,j] = (Œ±·µ¢‚±º·¥∏‚Åª..Œ±·µ¢‚±º·µÅ‚Åª, Œ±·µ¢‚±º·¥∏‚Å∫..Œ±·µ¢‚±º·µÅ‚Å∫)
            ùíú[j,i] = ((1/Œ±·µ¢‚±º·µÅ‚Åª)..(1/Œ±·µ¢‚±º·¥∏‚Åª), (1/Œ±·µ¢‚±º·µÅ‚Å∫)..(1/Œ±·µ¢‚±º·¥∏‚Å∫))
        end
    end

    if !isTwofoldIntervalPCM(ùíú)
        throw(ErrorException("Failed to generate TwofoldInterval PCM."))
    end

    return ùíú
end

LPResult = @NamedTuple{
    w·¥∏::Vector{T}, w·µÅ::Vector{T},
    w·¥∏‚Åª::Vector{T}, w·µÅ‚Åª::Vector{T},
    w·¥∏‚Å∫::Vector{T}, w·µÅ‚Å∫::Vector{T},
    Œµ·¥∏::Vector{T}, Œµ·µÅ::Vector{T},
    optimalValue::T
} where {T <: Real}

function solveConsistentizationLP(
    ùíú::Matrix{TwofoldInterval{T}}
)::LPResult{T} where {T <: Real}
    if !isTwofoldIntervalPCM(ùíú)
        throw(ArgumentError("Given matrix is not valid as twofold interval matrix."))
    end

    n = size(ùíú, 1)

    model = Model(HiGHS.Optimizer)
    set_silent(model)

    try
        @variable(model, w·¥∏[i=1:n] ‚â• 1e-10); @variable(model, w·µÅ[i=1:n] ‚â• 1e-10)
        @variable(model, w·¥∏‚Åª[i=1:n] ‚â• 0); @variable(model, w·µÅ‚Åª[i=1:n] ‚â• 0)
        @variable(model, w·¥∏‚Å∫[i=1:n] ‚â• 0); @variable(model, w·µÅ‚Å∫[i=1:n] ‚â• 0)
        @variable(model, Œµ·¥∏[i=1:n] ‚â• 0); @variable(model, Œµ·µÅ[i=1:n] ‚â• 0)

        for i = 1:n
            w·µ¢·¥∏ = w·¥∏[i]; w·µ¢·µÅ = w·µÅ[i]
            w·µ¢·¥∏‚Åª = w·¥∏‚Åª[i]; w·µ¢·µÅ‚Åª = w·µÅ‚Åª[i]
            w·µ¢·¥∏‚Å∫ = w·¥∏‚Å∫[i]; w·µ¢·µÅ‚Å∫ = w·µÅ‚Å∫[i]
            Œµ·µ¢·¥∏ = Œµ·¥∏[i]; Œµ·µ¢·µÅ = Œµ·µÅ[i]

            @constraint(model, w·µ¢·µÅ ‚â• w·µ¢·¥∏)
            @constraint(model, Œµ·µ¢·¥∏ ‚â• w·µ¢·¥∏‚Å∫ - w·µ¢·¥∏‚Åª)
            @constraint(model, Œµ·µ¢·µÅ ‚â• w·µ¢·µÅ‚Åª - w·µ¢·µÅ‚Å∫)

            ‚àëw‚±º·¥∏ = sum(map(j -> w·¥∏[j], filter(j -> i != j, 1:n)))
            @constraint(model, ‚àëw‚±º·¥∏ + w·µ¢·µÅ ‚â§ 1)
            ‚àëw‚±º·µÅ = sum(map(j -> w·µÅ[j], filter(j -> i != j, 1:n)))
            @constraint(model, ‚àëw‚±º·µÅ + w·µ¢·¥∏ ‚â• 1)

            for j = 1:n
                if i == j continue end

                Œ±·µ¢‚±º·¥∏‚Åª = inf(ùíú[i,j][1]); Œ±·µ¢‚±º·µÅ‚Åª = sup(ùíú[i,j][1])
                Œ±·µ¢‚±º·¥∏‚Å∫ = inf(ùíú[i,j][2]); Œ±·µ¢‚±º·µÅ‚Å∫ = sup(ùíú[i,j][2])
                w‚±º·¥∏ = w·¥∏[j]; w‚±º·µÅ = w·µÅ[j]

                @constraint(model, Œ±·µ¢‚±º·¥∏‚Å∫ * w‚±º·µÅ - Œµ·µ¢·¥∏ ‚â§ w·µ¢·¥∏)
                @constraint(model, w·µ¢·¥∏ ‚â§ Œ±·µ¢‚±º·¥∏‚Åª * w‚±º·µÅ + Œµ·µ¢·¥∏)
                @constraint(model, Œ±·µ¢‚±º·µÅ‚Åª * w‚±º·¥∏ - Œµ·µ¢·µÅ ‚â§ w·µ¢·µÅ)
                @constraint(model, w·µ¢·µÅ ‚â§ Œ±·µ¢‚±º·µÅ‚Å∫ * w‚±º·¥∏ + Œµ·µ¢·µÅ)
                @constraint(model, w·µ¢·¥∏‚Åª ‚â§ Œ±·µ¢‚±º·¥∏‚Åª * w‚±º·µÅ)
                @constraint(model, w·µ¢·¥∏‚Å∫ ‚â• Œ±·µ¢‚±º·¥∏‚Å∫ * w‚±º·µÅ)
                @constraint(model, w·µ¢·µÅ‚Åª ‚â• Œ±·µ¢‚±º·µÅ‚Åª * w‚±º·¥∏)
                @constraint(model, w·µ¢·µÅ‚Å∫ ‚â§ Œ±·µ¢‚±º·µÅ‚Å∫ * w‚±º·¥∏)
            end
        end
        
        @constraint(model, sum(w·¥∏) + sum(w·µÅ) == 2)

        @objective(model, Min, sum(Œµ·¥∏) + sum(Œµ·µÅ))

        optimize!(model)

        optimalValue = sum(value.(Œµ·¥∏)) + sum(value.(Œµ·µÅ))

        ≈µ·¥∏‚Åª = correctPrecisionLoss(value.(w·¥∏‚Åª), value.(w·¥∏‚Å∫))
        ≈µ·µÅ‚Åª = correctPrecisionLoss(value.(w·µÅ‚Åª), value.(≈µ·¥∏‚Åª))
        ≈µ·µÅ‚Å∫ = correctPrecisionLoss(value.(w·µÅ‚Å∫), value.(≈µ·µÅ‚Åª))

        return (
            w·¥∏=correctPrecisionLoss(value.(w·¥∏), value.(w·µÅ)),
            w·µÅ=value.(w·µÅ),
            w·¥∏‚Åª=≈µ·¥∏‚Åª,
            w·µÅ‚Åª=≈µ·µÅ‚Åª,
            w·¥∏‚Å∫=value.(w·¥∏‚Å∫),
            w·µÅ‚Å∫=≈µ·µÅ‚Å∫,
            Œµ·¥∏=value.(Œµ·¥∏),
            Œµ·µÅ=value.(Œµ·µÅ),
            optimalValue=optimalValue
        )
    finally
        empty!(model)
    end
end

function consistentize(
    ùíú::Matrix{TwofoldInterval{T}},
    result::LPResult{T}
)::Matrix{TwofoldInterval{T}} where {T <: Real}
    n = size(ùíú, 1)
    w·¥∏ = result.w·¥∏; w·µÅ = result.w·µÅ
    w·¥∏‚Åª = result.w·¥∏‚Åª; w·µÅ‚Åª = result.w·µÅ‚Åª
    w·¥∏‚Å∫ = result.w·¥∏‚Å∫; w·µÅ‚Å∫ = result.w·µÅ‚Å∫

    ùíú·∂ú = Matrix{TwofoldInterval{T}}(undef, n, n)

    for i = 1:n
        for j = 1:n
            if i == j
                ùíú·∂ú[i,i] = (1.0..1.0, 1.0..1.0)
                continue
            end

            ùíú·µ¢‚±º = ùíú[i,j]
            ùíú·µ¢‚±º‚Åª = TwofoldIntervalArithmetic.inner(ùíú·µ¢‚±º)
            ùíú·µ¢‚±º‚Å∫ = TwofoldIntervalArithmetic.outer(ùíú·µ¢‚±º)
            Œ±·µ¢‚±º·¥∏‚Åª = inf(ùíú·µ¢‚±º‚Åª); Œ±·µ¢‚±º·µÅ‚Åª = sup(ùíú·µ¢‚±º‚Åª)
            Œ±·µ¢‚±º·¥∏‚Å∫ = inf(ùíú·µ¢‚±º‚Å∫); Œ±·µ¢‚±º·µÅ‚Å∫ = sup(ùíú·µ¢‚±º‚Å∫)
            w·µ¢·¥∏ = w·¥∏[i]; w·µ¢·µÅ = w·µÅ[i]
            w·µ¢·¥∏‚Åª = w·¥∏‚Åª[i]; w·µ¢·µÅ‚Åª = w·µÅ‚Åª[i]
            w·µ¢·¥∏‚Å∫ = w·¥∏‚Å∫[i]; w·µ¢·µÅ‚Å∫ = w·µÅ‚Å∫[i]
            w‚±º·¥∏ = w·¥∏[j]; w‚±º·µÅ = w·µÅ[j]
            w‚±º·¥∏‚Åª = w·¥∏‚Åª[j]; w‚±º·µÅ‚Åª = w·µÅ‚Åª[j]
            w‚±º·¥∏‚Å∫ = w·¥∏‚Å∫[j]; w‚±º·µÅ‚Å∫ = w·µÅ‚Å∫[j]
            w·µ¢·¥∏ = w·¥∏[i]; w·µ¢·µÅ = w·µÅ[i]
            w·µ¢·¥∏‚Åª = w·¥∏‚Åª[i]; w·µ¢·µÅ‚Åª = w·µÅ‚Åª[i]
            w·µ¢·¥∏‚Å∫ = w·¥∏‚Å∫[i]; w·µ¢·µÅ‚Å∫ = w·µÅ‚Å∫[i]
            w‚±º·¥∏ = w·¥∏[j]; w‚±º·µÅ = w·µÅ[j]
            w‚±º·¥∏‚Åª = w·¥∏‚Åª[j]; w‚±º·µÅ‚Åª = w·µÅ‚Åª[j]
            w‚±º·¥∏‚Å∫ = w·¥∏‚Å∫[j]; w‚±º·µÅ‚Å∫ = w·µÅ‚Å∫[j]

            Œ±·µ¢‚±º·∂ú·¥∏‚Å∫ = min(Œ±·µ¢‚±º·¥∏‚Å∫, w·µ¢·¥∏‚Åª/w‚±º·µÅ, w·µ¢·¥∏/w‚±º·µÅ‚Åª)
            Œ±·µ¢‚±º·∂ú·¥∏‚Åª = max(Œ±·µ¢‚±º·¥∏‚Åª, w·µ¢·¥∏‚Å∫/w‚±º·µÅ, w·µ¢·¥∏/w‚±º·µÅ‚Å∫)
            Œ±·µ¢‚±º·∂ú·µÅ‚Åª = min(Œ±·µ¢‚±º·µÅ‚Åª, w·µ¢·µÅ‚Å∫/w‚±º·¥∏, w·µ¢·µÅ/w‚±º·¥∏‚Å∫)
            Œ±·µ¢‚±º·∂ú·µÅ‚Å∫ = max(Œ±·µ¢‚±º·µÅ‚Å∫, w·µ¢·µÅ‚Åª/w‚±º·¥∏, w·µ¢·µÅ/w‚±º·¥∏‚Åª)

            Œ±·µ¢‚±º·∂ú·¥∏‚Åª = correctPrecisionLoss(Œ±·µ¢‚±º·∂ú·¥∏‚Åª, Œ±·µ¢‚±º·∂ú·¥∏‚Å∫)
            Œ±·µ¢‚±º·∂ú·µÅ‚Åª = correctPrecisionLoss(Œ±·µ¢‚±º·∂ú·µÅ‚Åª, Œ±·µ¢‚±º·∂ú·¥∏‚Åª)
            Œ±·µ¢‚±º·∂ú·µÅ‚Å∫ = correctPrecisionLoss(Œ±·µ¢‚±º·∂ú·µÅ‚Å∫, Œ±·µ¢‚±º·∂ú·µÅ‚Åª)
            Œ±·µ¢‚±º·∂ú·¥∏‚Å∫ = min(Œ±·µ¢‚±º·∂ú·¥∏‚Å∫, Œ±·µ¢‚±º·∂ú·µÅ‚Å∫)

            if Œ±·µ¢‚±º·∂ú·¥∏‚Åª > Œ±·µ¢‚±º·∂ú·µÅ‚Åª
                ùíú·∂ú[i,j] = (emptyinterval(), Œ±·µ¢‚±º·∂ú·¥∏‚Å∫..Œ±·µ¢‚±º·∂ú·µÅ‚Å∫)
            else
                ùíú·∂ú[i,j] = (Œ±·µ¢‚±º·∂ú·¥∏‚Åª..Œ±·µ¢‚±º·∂ú·µÅ‚Åª, Œ±·µ¢‚±º·∂ú·¥∏‚Å∫..Œ±·µ¢‚±º·∂ú·µÅ‚Å∫)
            end
        end
    end

    if !isTwofoldIntervalPCM(ùíú·∂ú)
        throw(ErrorException("Failed to consistentize a twofold interval PCM."))
    end

    return ùíú·∂ú
end

function method1(
    A‚ÇÅ::Matrix{Interval{T}},
    A‚ÇÇ::Matrix{Interval{T}}
)::Matrix{TwofoldInterval{T}} where {T <: Real}
    ùíú = combineIntervalPCMs(A‚ÇÅ, A‚ÇÇ)
    result = solveConsistentizationLP(ùíú)
    return consistentize(ùíú, result)
end

export method1

end
