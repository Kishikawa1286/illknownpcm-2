# This file is auto-generated from twofold_interval_pcm.jmd.
# Do not edit this file manually.

module TwofoldIntervalPCM

using IntervalArithmetic
using IntervalArithmetic.Symbols

include("../../nearly_equal/v1/nearly_equal.jl")
using .NearlyEqual

include("../../twofold_interval/v1/twofold_interval.jl")
using .TwofoldIntervalArithmetic

include("../../interval_pcm/v1/interval_pcm.jl")
using .IntervalPCM

include("../../interval_weight_vector/v1/interval_weight_vector.jl")
using .IntervalWeightVector

include("../../twofold_interval_weight_vector/v1/twofold_interval_weight_vector.jl")
using .TwofoldIntervalWeightVector
import .TwofoldIntervalWeightVector: ∈, ∋

"""
    isTwofoldIntervalPCM(
        𝒜;
        allow_uncommon_inner_interval=true,
        strict=false
    )

Check if the matrix `𝒜` is a twofold interval PCM.
"""
@inline function isTwofoldIntervalPCM(
    𝒜::Matrix{TwofoldInterval{T}};
    allow_uncommon_inner_interval::Bool=true,
    strict::Bool=false
)::Bool where {T <: Real}
    tolerance = strict ? 1e-10 : 1e-6

    m, n = size(𝒜)
    # Check if the matrix is square
    if m != n return false end

    𝒜⁻ = inner(𝒜); 𝒜⁺ = outer(𝒜)

    for i = 1:n, j = 1:n
        if !isTwofoldInterval(𝒜[i, j];
            allow_uncommon_inner_interval=allow_uncommon_inner_interval,
            strict=strict
        ) return false end

        𝒜ᵢⱼ⁻ = 𝒜⁻[i, j]; 𝒜ᵢⱼ⁺ = 𝒜⁺[i, j]

        # If the inner interval of 𝒜ᵢⱼ⁻ is ∅
        if !iscommon(𝒜ᵢⱼ⁻)
            # 𝒜ᵢᵢ⁻ must be [1,1]
            if i == j return false end

            αᵢⱼᴸ⁺ = inf(𝒜ᵢⱼ⁺); αᵢⱼᵁ⁺ = sup(𝒜ᵢⱼ⁺)
            𝒜ⱼᵢ⁺ = 𝒜⁺[j, i]
            αⱼᵢᴸ⁺ = inf(𝒜ⱼᵢ⁺); αⱼᵢᵁ⁺ = sup(𝒜ⱼᵢ⁺)

            # Check reciprocity
            if !isNearlyEqual(αᵢⱼᴸ⁺, 1 / αⱼᵢᵁ⁺, tolerance=tolerance) return false end
            if !isNearlyEqual(αᵢⱼᵁ⁺, 1 / αⱼᵢᴸ⁺, tolerance=tolerance) return false end

            continue
        end

        αᵢⱼᴸ⁻ = inf(𝒜ᵢⱼ⁻); αᵢⱼᵁ⁻ = sup(𝒜ᵢⱼ⁻)
        αᵢⱼᴸ⁺ = inf(𝒜ᵢⱼ⁺); αᵢⱼᵁ⁺ = sup(𝒜ᵢⱼ⁺)

        # Check whether the diagonal elements are ([1,1], [1,1])
        if i == j
            if !isNearlyEqual(αᵢⱼᴸ⁻, 1.0, tolerance=1e-10) return false end
            if !isNearlyEqual(αᵢⱼᵁ⁻, 1.0, tolerance=1e-10) return false end
            if !isNearlyEqual(αᵢⱼᴸ⁺, 1.0, tolerance=1e-10) return false end
            if !isNearlyEqual(αᵢⱼᵁ⁺, 1.0, tolerance=1e-10) return false end
            continue
        end

        𝒜ⱼᵢ⁻ = 𝒜⁻[j, i]; 𝒜ⱼᵢ⁺ = 𝒜⁺[j, i]
        αⱼᵢᴸ⁻ = inf(𝒜ⱼᵢ⁻); αⱼᵢᵁ⁻ = sup(𝒜ⱼᵢ⁻)
        αⱼᵢᴸ⁺ = inf(𝒜ⱼᵢ⁺); αⱼᵢᵁ⁺ = sup(𝒜ⱼᵢ⁺)

        # Check reciprocity
        if !isNearlyEqual(αᵢⱼᴸ⁻, 1 / αⱼᵢᵁ⁻, tolerance=tolerance) return false end
        if !isNearlyEqual(αᵢⱼᵁ⁻, 1 / αⱼᵢᴸ⁻, tolerance=tolerance) return false end
        if !isNearlyEqual(αᵢⱼᴸ⁺, 1 / αⱼᵢᵁ⁺, tolerance=tolerance) return false end
        if !isNearlyEqual(αᵢⱼᵁ⁺, 1 / αⱼᵢᴸ⁺, tolerance=tolerance) return false end
    end
    return true
end

export isTwofoldIntervalPCM

"""
    isTwofoldIntervalPCMContainingIntervalPCM(
        A,
        𝒜;
        strict=false
    )

Check if the interval PCM `A` is contained in the twofold interval PCM `𝒜`.
Throws a `DimensionMismatch` if the sizes of the given matrices `A` and `𝒜` are not the same.
Throw an `ArgumentError` if the given matrices `A` and `𝒜` are not interval PCMs.
"""
function isTwofoldIntervalPCMContainingIntervalPCM(
    A::Matrix{Interval{T}},
    𝒜::Matrix{TwofoldInterval{T}};
    strict::Bool=false
)::Bool where {T <: Real}
    if !isIntervalPCM(A)
        throw(ArgumentError("A must be an interval PCM."))
    end
    if !isTwofoldIntervalPCM(𝒜)
        throw(ArgumentError("𝒜 must be a twofold interval PCM."))
    end

    if size(A) != size(𝒜)
        throw(DimensionMismatch("The sizes of A and 𝒜 must be the same."))
    end

    tolerance = strict ? 1e-10 : 1e-6

    n = size(A, 1)
    𝒜⁻ = inner(𝒜); 𝒜⁺ = outer(𝒜)

    for i = 1:n, j = 1:n
        𝒜ᵢⱼ⁻ = 𝒜⁻[i, j]; 𝒜ᵢⱼ⁺ = 𝒜⁺[i, j]
        αᵢⱼᴸ⁻ = inf(𝒜ᵢⱼ⁻); αᵢⱼᵁ⁻ = sup(𝒜ᵢⱼ⁻)
        αᵢⱼᴸ⁺ = inf(𝒜ᵢⱼ⁺); αᵢⱼᵁ⁺ = sup(𝒜ᵢⱼ⁺)
        Aᵢⱼ = A[i, j]
        aᵢⱼᴸ = inf(Aᵢⱼ); aᵢⱼᵁ = sup(Aᵢⱼ)

        if αᵢⱼᴸ⁻ ≤ aᵢⱼᴸ && aᵢⱼᵁ ≤ αᵢⱼᵁ⁺ continue end

        if isNearlyEqual(αᵢⱼᴸ⁺, aᵢⱼᴸ; tolerance=tolerance) continue end
        if isNearlyEqual(aᵢⱼᴸ, αᵢⱼᴸ⁻; tolerance=tolerance) continue end
        if isNearlyEqual(αᵢⱼᵁ⁻, aᵢⱼᵁ; tolerance=tolerance) continue end
        if isNearlyEqual(aᵢⱼᵁ, αᵢⱼᵁ⁺; tolerance=tolerance) continue end

        throw(ErrorException("The interval PCM A is not contained in the twofold interval PCM 𝒜 at indices ($i, $j)."))

        return false
    end

    return true
end

"""
    ∈(A, 𝒜)

Unicode alias for `isTwofoldIntervalPCMContainingIntervalPCM(A, 𝒜)`.
"""
∈(A::Matrix{Interval{T}}, 𝒜::Matrix{TwofoldInterval{T}}) where {T <: Real} = isTwofoldIntervalPCMContainingIntervalPCM(A, 𝒜)

"""
    ∋(𝒜, A)

Unicode alias for `isTwofoldIntervalPCMContainingIntervalPCM(A, 𝒜)`.
"""
∋(𝒜::Matrix{TwofoldInterval{T}}, A::Matrix{Interval{T}}) where {T <: Real} = isTwofoldIntervalPCMContainingIntervalPCM(A, 𝒜)

export isTwofoldIntervalPCMContainingIntervalPCM, ∈, ∋

"""
    twofoldIntervalMatrix(𝒜⁻, 𝒜⁺)

Create a twofold interval matrix from the inner and outer interval matrices.
Given the two interval matrices must have the same size.
"""
function twofoldIntervalMatrix(
    𝒜⁻::Matrix{Interval{T}},
    𝒜⁺::Matrix{Interval{T}}
)::Matrix{TwofoldInterval{T}} where {T <: Real}
    if size(𝒜⁻) != size(𝒜⁺)
        throw(DimensionMismatch("The sizes of 𝒜⁻ and 𝒜⁺ must be the same."))
    end

    m, n = size(𝒜⁻)
    𝒜 = Matrix{TwofoldInterval}(undef, m, n)

    for i = 1:m, j = 1:n
        𝒜[i, j] = (𝒜⁻[i, j], 𝒜⁺[i, j])
    end

    return 𝒜
end

"""
    twofoldIntervalPCM(𝒲)

Create a twofold interval PCM from a twofold interval weight vector.
"""
function twofoldIntervalPCM(
    𝒲::Vector{TwofoldInterval{T}}
)::Matrix{TwofoldInterval{T}} where {T <: Real}
    if !isTwofoldIntervalWeightVector(𝒲)
        throw(ArgumentError("𝒲 must be a twofold interval weight vector."))
    end

    n = length(𝒲)

    𝒜 = Matrix{TwofoldInterval}(undef, n, n)

    for i = 1:n, j = 1:n
        if i == j
            𝒜[i, j] = (1..1, 1..1)
            continue
        end

        𝒲ᵢ = 𝒲[i]; 𝒲ⱼ = 𝒲[j]
        𝒲ᵢ⁻ = inner(𝒲ᵢ); 𝒲ᵢ⁺ = outer(𝒲ᵢ)
        𝒲ⱼ⁻ = inner(𝒲ⱼ); 𝒲ⱼ⁺ = outer(𝒲ⱼ)
        wᵢᴸ⁻ = inf(𝒲ᵢ⁻); wᵢᵁ⁻ = sup(𝒲ᵢ⁻)
        wᵢᴸ⁺ = inf(𝒲ᵢ⁺); wᵢᵁ⁺ = sup(𝒲ᵢ⁺)
        wⱼᴸ⁻ = inf(𝒲ⱼ⁻); wⱼᵁ⁻ = sup(𝒲ⱼ⁻)
        wⱼᴸ⁺ = inf(𝒲ⱼ⁺); wⱼᵁ⁺ = sup(𝒲ⱼ⁺)

        αᵢⱼᴸ⁻ = wᵢᴸ⁻ / wⱼᵁ⁻; αᵢⱼᵁ⁻ = wᵢᵁ⁻ / wⱼᴸ⁻
        αᵢⱼᴸ⁺ = wᵢᴸ⁺ / wⱼᵁ⁺; αᵢⱼᵁ⁺ = wᵢᵁ⁺ / wⱼᴸ⁺

        𝒜ᵢⱼ⁻ = αᵢⱼᴸ⁻..αᵢⱼᵁ⁻; 𝒜ᵢⱼ⁺ = αᵢⱼᴸ⁺..αᵢⱼᵁ⁺

        𝒜[i, j] = (𝒜ᵢⱼ⁻, 𝒜ᵢⱼ⁺)
    end

    return 𝒜
end

"""
    twofoldIntervalPCM(𝒜⁻, 𝒜⁺)

Create a twofold interval PCM from the inner and outer interval matrices.
Throw an `ArgumentError` if the given matrices `𝒜⁻` and `𝒜⁺` are not interval PCMs.
"""
function twofoldIntervalPCM(
    𝒜⁻::Matrix{Interval{T}},
    𝒜⁺::Matrix{Interval{T}}
)::Matrix{TwofoldInterval{T}} where {T <: Real}
    if !isIntervalPCM(𝒜⁻)
        throw(ArgumentError("𝒜⁻ must be an interval PCM."))
    end
    if !isIntervalPCM(𝒜⁺)
        throw(ArgumentError("𝒜⁺ must be an interval PCM."))
    end

    𝒜 = twofoldIntervalMatrix(𝒜⁻, 𝒜⁺)
    if !isTwofoldIntervalPCM(𝒜)
    # Failed calculation
        throw(ErrorException("Failed to create a twofold interval PCM."))
    end

    return 𝒜
end

export twofoldIntervalMatrix, twofoldIntervalPCM

end
