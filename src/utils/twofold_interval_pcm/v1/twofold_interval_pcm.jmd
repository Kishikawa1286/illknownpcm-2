# TwofoldIntervalPCM

```julia
import Base: âˆˆ, âˆ‹
using IntervalArithmetic
using IntervalArithmetic.Symbols

include("../../nearly_equal/v1/nearly_equal.jl")
using .NearlyEqual

include("../../twofold_interval/v1/twofold_interval.jl")
using .TwofoldIntervalArithmetic

include("../../interval_pcm/v1/interval_pcm.jl")
using .IntervalPCM
```

## äºŒé‡åŒºé–“ PCM ã®å®šç¾©

$$
\mathscr{A}
= \left( \left( \mathscr{A}_{ij}^-, \mathscr{A}_{ij}^+ \right) \right)_{n \times n}
= \left( \left( \left[
    \alpha^{\mathrm{L}-}, \alpha^{\mathrm{U}-}
\right], \left[
    \alpha^{\mathrm{L}+}, \alpha^{\mathrm{U}+}
\right] \right) \right)_{n \times n}
$$

- $n \times n$ è¡Œåˆ—
- $\mathscr{A}_{ij}^- \subseteq \mathscr{A}_{ij}^+ ~~ (\alpha_{ij}^{\mathrm{L}+} \leq \alpha_{ij}^{\mathrm{L}-}, ~ \alpha_{ij}^{\mathrm{U}-} \leq \alpha_{ij}^{\mathrm{U}+}), ~ i, j \in N$
- $\alpha_{ij}^{\mathrm{L}+} > 0, ~ i, j \in N$
- $\mathscr{A}_{ii}^- = \mathscr{A}_{ii}^+ = [1, 1], ~ i \in N$
- $\alpha_{ij}^{\mathrm{L}-} = 1/\alpha_{ji}^{\mathrm{U}-}, ~ \alpha_{ij}^{\mathrm{L}+} = 1/\alpha_{ji}^{\mathrm{U}+}, ~ i, j \in N$

```julia
"""
    isTwofoldIntervalPCM(ğ’œ;
        allow_uncommon_inner_interval=true,
        strict=false)

Check if the matrix `ğ’œ` is a twofold interval PCM.
"""
@inline function isTwofoldIntervalPCM(
    ğ’œ::Matrix{TwofoldInterval{T}};
    allow_uncommon_inner_interval::Bool=true,
    strict::Bool=false
)::Bool where {T <: Real}
    m, n = size(ğ’œ)
    # Check if the matrix is square
    if m != n return false end

    ğ’œâ» = inner(ğ’œ); ğ’œâº = outer(ğ’œ)

    for i = 1:n, j = 1:n
        if !isTwofoldInterval(ğ’œ[i, j];
            allow_uncommon_inner_interval=allow_uncommon_inner_interval,
            strict=strict
        ) return false end

        ğ’œáµ¢â±¼â» = ğ’œâ»[i, j]; ğ’œáµ¢â±¼âº = ğ’œâº[i, j]

        # If the inner interval of ğ’œáµ¢â±¼â» is âˆ…
        if !iscommon(ğ’œáµ¢â±¼â»)
            # ğ’œáµ¢áµ¢â» must be [1,1]
            if i == j return false end

            Î±áµ¢â±¼á´¸âº = inf(ğ’œáµ¢â±¼âº); Î±áµ¢â±¼áµâº = sup(ğ’œáµ¢â±¼âº)
            ğ’œâ±¼áµ¢âº = ğ’œâº[j, i]
            Î±â±¼áµ¢á´¸âº = inf(ğ’œâ±¼áµ¢âº); Î±â±¼áµ¢áµâº = sup(ğ’œâ±¼áµ¢âº)

            # Check reciprocity
            if strict
                if !isNearlyEqual(Î±áµ¢â±¼á´¸âº, 1 / Î±â±¼áµ¢áµâº, tolerance=1e-10) return false end
                if !isNearlyEqual(Î±áµ¢â±¼áµâº, 1 / Î±â±¼áµ¢á´¸âº, tolerance=1e-10) return false end
            else
                if !isNearlyEqual(Î±áµ¢â±¼á´¸âº, 1 / Î±â±¼áµ¢áµâº) return false end
                if !isNearlyEqual(Î±áµ¢â±¼áµâº, 1 / Î±â±¼áµ¢á´¸âº) return false end
            end

            continue
        end

        Î±áµ¢â±¼á´¸â» = inf(ğ’œáµ¢â±¼â»); Î±áµ¢â±¼áµâ» = sup(ğ’œáµ¢â±¼â»)
        Î±áµ¢â±¼á´¸âº = inf(ğ’œáµ¢â±¼âº); Î±áµ¢â±¼áµâº = sup(ğ’œáµ¢â±¼âº)

        # Check whether the diagonal elements are ([1,1], [1,1])
        if i == j
            if !isNearlyEqual(Î±áµ¢â±¼á´¸â», 1.0, tolerance=1e-10) return false end
            if !isNearlyEqual(Î±áµ¢â±¼áµâ», 1.0, tolerance=1e-10) return false end
            if !isNearlyEqual(Î±áµ¢â±¼á´¸âº, 1.0, tolerance=1e-10) return false end
            if !isNearlyEqual(Î±áµ¢â±¼áµâº, 1.0, tolerance=1e-10) return false end
            continue
        end

        ğ’œâ±¼áµ¢â» = ğ’œâ»[j, i]; ğ’œâ±¼áµ¢âº = ğ’œâº[j, i]
        Î±â±¼áµ¢á´¸â» = inf(ğ’œâ±¼áµ¢â»); Î±â±¼áµ¢áµâ» = sup(ğ’œâ±¼áµ¢â»)
        Î±â±¼áµ¢á´¸âº = inf(ğ’œâ±¼áµ¢âº); Î±â±¼áµ¢áµâº = sup(ğ’œâ±¼áµ¢âº)

        # Check reciprocity
        if strict
            if !isNearlyEqual(Î±áµ¢â±¼á´¸â», 1 / Î±â±¼áµ¢áµâ», tolerance=1e-10) return false end
            if !isNearlyEqual(Î±áµ¢â±¼áµâ», 1 / Î±â±¼áµ¢á´¸â», tolerance=1e-10) return false end
            if !isNearlyEqual(Î±áµ¢â±¼á´¸âº, 1 / Î±â±¼áµ¢áµâº, tolerance=1e-10) return false end
            if !isNearlyEqual(Î±áµ¢â±¼áµâº, 1 / Î±â±¼áµ¢á´¸âº, tolerance=1e-10) return false end
        else
            if !isNearlyEqual(Î±áµ¢â±¼á´¸â», 1 / Î±â±¼áµ¢áµâ») return false end
            if !isNearlyEqual(Î±áµ¢â±¼áµâ», 1 / Î±â±¼áµ¢á´¸â») return false end
            if !isNearlyEqual(Î±áµ¢â±¼á´¸âº, 1 / Î±â±¼áµ¢áµâº) return false end
            if !isNearlyEqual(Î±áµ¢â±¼áµâº, 1 / Î±â±¼áµ¢á´¸âº) return false end
        end
    end
    return true
end
```

## åŒºé–“ PCM ãŒäºŒé‡åŒºé–“ PCM ã«å«ã¾ã‚Œã‚‹ã‹ã©ã†ã‹ã®åˆ¤å®š

$\mathscr{A}$ ã‚’äºŒé‡åŒºé–“ PCM ã¨ã—ï¼Œ$A$ ã‚’åŒºé–“ PCM ã¨ã™ã‚‹ï¼$A$ ãŒ $\mathscr{A}$ ã«å«ã¾ã‚Œã‚‹ã¨ã¯ï¼Œ$\mathscr{A}_{ij}^- \subseteq A_{ij}^- \subseteq A_{ij}^+, ~ i, j \in N$ ãŒæˆã‚Šç«‹ã¤ã“ã¨ã§ã‚ã‚‹ï¼

```julia
"""
    isTwofoldIntervalPCMContainingIntervalPCM(
        A,
        ğ’œ;
        strict=false
    )

Check if the interval PCM `A` is contained in the twofold interval PCM `ğ’œ`.
Throws a `DimensionMismatch` if the sizes of the given matrices `A` and `ğ’œ` are not the same.
Throw an `ArgumentError` if the given matrices `A` and `ğ’œ` are not interval PCMs.
"""
function isTwofoldIntervalPCMContainingIntervalPCM(
    A::Matrix{Interval{T}},
    ğ’œ::Matrix{TwofoldInterval{T}};
    strict::Bool=false
)::Bool where {T <: Real}
    if !isIntervalPCM(A)
        throw(ArgumentError("A must be an interval PCM."))
    end
    if !isTwofoldIntervalPCM(ğ’œ)
        throw(ArgumentError("ğ’œ must be a twofold interval PCM."))
    end

    if size(A) != size(ğ’œ)
        throw(DimensionMismatch("The sizes of A and ğ’œ must be the same."))
    end

    tolerance = strict ? 1e-10 : 1e-6

    n = size(A, 1)
    ğ’œâ» = inner(ğ’œ); ğ’œâº = outer(ğ’œ)

    for i = 1:n, j = 1:n
        ğ’œáµ¢â±¼â» = ğ’œâ»[i, j]; ğ’œáµ¢â±¼âº = ğ’œâº[i, j]
        Î±áµ¢â±¼á´¸â» = inf(ğ’œáµ¢â±¼â»); Î±áµ¢â±¼áµâ» = sup(ğ’œáµ¢â±¼â»)
        Î±áµ¢â±¼á´¸âº = inf(ğ’œáµ¢â±¼âº); Î±áµ¢â±¼áµâº = sup(ğ’œáµ¢â±¼âº)
        Aáµ¢â±¼ = A[i, j]
        aáµ¢â±¼á´¸ = inf(Aáµ¢â±¼); aáµ¢â±¼áµ = sup(Aáµ¢â±¼)

        if Î±áµ¢â±¼á´¸â» â‰¤ aáµ¢â±¼á´¸ && aáµ¢â±¼áµ â‰¤ Î±áµ¢â±¼áµâº continue end

        if isNearlyEqual(Î±áµ¢â±¼á´¸âº, aáµ¢â±¼á´¸; tolerance=tolerance) continue end
        if isNearlyEqual(aáµ¢â±¼á´¸, Î±áµ¢â±¼á´¸â»; tolerance=tolerance) continue end
        if isNearlyEqual(Î±áµ¢â±¼áµâ», aáµ¢â±¼áµ; tolerance=tolerance) continue end
        if isNearlyEqual(aáµ¢â±¼áµ, Î±áµ¢â±¼áµâº; tolerance=tolerance) continue end

        throw(ErrorException("The interval PCM A is not contained in the twofold interval PCM ğ’œ at indices ($i, $j)."))

        return false
    end

    return true
end
```

```julia
"""
    âˆˆ(A, ğ’œ)

Unicode alias for `isTwofoldIntervalPCMContainingIntervalPCM(A, ğ’œ)`.
"""
âˆˆ(A::Matrix{Interval{T}}, ğ’œ::Matrix{TwofoldInterval{T}}) where {T <: Real} = isTwofoldIntervalPCMContainingIntervalPCM(A, ğ’œ)
```

```julia
"""
    âˆ‹(ğ’œ, A)

Unicode alias for `isTwofoldIntervalPCMContainingIntervalPCM(A, ğ’œ)`.
"""
âˆ‹(ğ’œ::Matrix{TwofoldInterval{T}}, A::Matrix{Interval{T}}) where {T <: Real} = isTwofoldIntervalPCMContainingIntervalPCM(A, ğ’œ)
```

## ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°

```julia
"""
    inner(ğ’œ)

Extract the interval matrix consisting of the inner intervals of the each element of the twofold interval matrix `ğ’œ`.
"""
function inner(
    ğ’œ::Matrix{TwofoldInterval{T}}
)::Matrix{Interval{T}} where {T <: Real}
    m, n = size(ğ’œ)
    ğ’œâ» = Matrix{Interval}(undef, m, n)

    for i = 1:m, j = 1:n
        ğ’œâ»[i, j] = ğ’œ[i, j][1]
    end

    return ğ’œâ»
end
```

```julia
"""
    outer(ğ’œ)

Extract the interval matrix consisting of the outer intervals of the each element of the twofold interval matrix `ğ’œ`.
"""
function outer(
    ğ’œ::Matrix{TwofoldInterval{T}}
)::Matrix{Interval{T}} where {T <: Real}
    m, n = size(ğ’œ)
    ğ’œâº = Matrix{Interval}(undef, m, n)

    for i = 1:m, j = 1:n
        ğ’œâº[i, j] = ğ’œ[i, j][2]
    end

    return ğ’œâº
end
```

```julia
"""
    createTwofoldIntervalMatrix(ğ’œâ», ğ’œâº)

Create a twofold interval matrix from the inner and outer interval matrices.
Given the two interval matrices must have the same size.
"""
function createTwofoldIntervalMatrix(
    ğ’œâ»::Matrix{Interval{T}},
    ğ’œâº::Matrix{Interval{T}}
)::Matrix{TwofoldInterval{T}} where {T <: Real}
    if size(ğ’œâ») != size(ğ’œâº)
        throw(DimensionMismatch("The sizes of ğ’œâ» and ğ’œâº must be the same."))
    end

    m, n = size(ğ’œâ»)
    ğ’œ = Matrix{TwofoldInterval}(undef, m, n)

    for i = 1:m, j = 1:n
        ğ’œ[i, j] = (ğ’œâ»[i, j], ğ’œâº[i, j])
    end

    return ğ’œ
end
```

```julia
"""
    createTwofoldIntervalPCM(ğ’œâ», ğ’œâº)

Create a twofold interval PCM from the inner and outer interval matrices.
Throw an `ArgumentError` if the given matrices `ğ’œâ»` and `ğ’œâº` are not interval PCMs.
"""
function createTwofoldIntervalPCM(
    ğ’œâ»::Matrix{Interval{T}},
    ğ’œâº::Matrix{Interval{T}}
)::Matrix{TwofoldInterval{T}} where {T <: Real}
    if !isIntervalPCM(ğ’œâ»)
        throw(ArgumentError("ğ’œâ» must be an interval PCM."))
    end
    if !isIntervalPCM(ğ’œâº)
        throw(ArgumentError("ğ’œâº must be an interval PCM."))
    end

    ğ’œ = createTwofoldIntervalMatrix(ğ’œâ», ğ’œâº)
    if !isTwofoldIntervalPCM(ğ’œ)
    # Failed calculation
        throw(ErrorException("Failed to create a twofold interval PCM."))
    end

    return ğ’œ
end
```

```julia
export isTwofoldIntervalPCM, inner, outer, isTwofoldIntervalPCMContainingIntervalPCM, âˆˆ, âˆ‹, createTwofoldIntervalMatrix, createTwofoldIntervalPCM
```
